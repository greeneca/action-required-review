{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChEA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././src/paths.js",".././src/reporter.js",".././src/request-review.js",".././src/requirement.js",".././src/reviewers.js",".././src/team-members.js",".././src/virtual-teams.js","../../../../../../opt/homebrew/Cellar/ncc/0.38.3/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"assert\"","../external node-commonjs \"fs\"","../webpack/bootstrap","../webpack/runtime/compat",".././src/main.js"],"sourcesContent":["const core = require( '@actions/core' );\nconst github = require( '@actions/github' );\nconst { WError } = require( 'error' );\n\n/**\n * Fetch the paths in the current PR.\n *\n * @return {string[]} Paths.\n */\nasync function fetchPaths() {\n\tconst octokit = github.getOctokit( core.getInput( 'token', { required: true } ) );\n\tconst owner = github.context.payload.repository.owner.login;\n\tconst repo = github.context.payload.repository.name;\n\tconst pr = github.context.payload.pull_request.number;\n\n\tconst paths = {};\n\ttry {\n\t\tfor await ( const res of octokit.paginate.iterator( octokit.rest.pulls.listFiles, {\n\t\t\towner: owner,\n\t\t\trepo: repo,\n\t\t\tpull_number: pr,\n\t\t\tper_page: 100,\n\t\t} ) ) {\n\t\t\tres.data.forEach( file => {\n\t\t\t\tpaths[ file.filename ] = true;\n\t\t\t\tif ( file.previous_filename ) {\n\t\t\t\t\tpaths[ file.previous_filename ] = true;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} catch ( error ) {\n\t\tthrow new WError(\n\t\t\t`Failed to query ${ owner }/${ repo } PR #${ pr } files from GitHub`,\n\t\t\terror,\n\t\t\t{}\n\t\t);\n\t}\n\n\treturn Object.keys( paths ).sort();\n}\n\nmodule.exports = fetchPaths;\n","const core = require( '@actions/core' );\nconst github = require( '@actions/github' );\nconst { WError } = require( 'error' );\n\nconst STATE_ERROR = 'error';\nconst STATE_FAILURE = 'failure';\nconst STATE_PENDING = 'pending';\nconst STATE_SUCCESS = 'success';\n\n/**\n * Report a status check to GitHub.\n *\n * @param {string} state       - One of the `STATE_*` constants.\n * @param {string} description - Description for the status.\n */\nasync function status( state, description ) {\n\tconst octokit = github.getOctokit( core.getInput( 'token', { required: true } ) );\n\tconst owner = github.context.payload.repository.owner.login;\n\tconst repo = github.context.payload.repository.name;\n\tconst req = {\n\t\towner: owner,\n\t\trepo: repo,\n\t\tsha: github.context.payload.pull_request.head.sha,\n\t\tstate: state,\n\t\ttarget_url: `${ github.context.serverUrl }/${ owner }/${ repo }/actions/runs/${ github.context.runId }`,\n\t\tdescription: description,\n\t\tcontext: core.getInput( 'status', { required: true } ),\n\t};\n\n\tif ( process.env.CI ) {\n\t\tawait octokit.rest.repos.createCommitStatus( req );\n\t} else {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.dir( req );\n\t}\n}\n\n/**\n * Error class for friendly GitHub Action error reporting.\n *\n * Use it like\n * ```\n * throw ReportError.create( 'Status description', originalError );\n * ```\n */\nclass ReportError extends WError {}\n\nmodule.exports = {\n\tSTATE_ERROR: STATE_ERROR,\n\tSTATE_FAILURE: STATE_FAILURE,\n\tSTATE_PENDING: STATE_PENDING,\n\tSTATE_SUCCESS: STATE_SUCCESS,\n\tstatus: status,\n\tReportError: ReportError,\n};\nmodule.exports.default = module.exports;\n","const core = require( '@actions/core' );\nconst github = require( '@actions/github' );\nconst addVirtualTeams = require( './virtual-teams.js' );\n\n/**\n * Request review from the given team\n *\n * @param {string[]} teams - GitHub team slug, or @ followed by a GitHub user name.\n */\nasync function requestReviewer( teams ) {\n\tconst octokit = github.getOctokit( core.getInput( 'token', { required: true } ) );\n\tconst owner = github.context.payload.repository.owner.login;\n\tconst repo = github.context.payload.repository.name;\n\tconst pr = github.context.payload.pull_request.number;\n\tconst author = `@${ github.context.payload.pull_request.user.login }`;\n\tif ( teams.includes( author ) ) {\n\t\tcore.info( `Skipping review for author ${ author }` );\n\t\tteams = teams.filter( team => team !== author );\n\t}\n\n\tconst userReviews = [];\n\tconst teamReviews = [];\n\n\tfor ( const t of teams ) {\n\t\tif ( t.startsWith( '@' ) && t.endsWith( '[bot]' ) ) {\n\t\t\tcore.info( `Skipping ${ t }, appears to be a bot` );\n\t\t} else if ( t.startsWith( '@' ) ) {\n\t\t\tuserReviews.push( t.slice( 1 ) );\n\t\t} else if ( t.startsWith( '+' ) ) {\n            await addVirtualTeams( userReviews, t );\n\t\t} else {\n\t\t\tteamReviews.push( t );\n\t\t}\n\t}\n\n\ttry {\n\t\tawait octokit.rest.pulls.requestReviewers( {\n\t\t\towner: owner,\n\t\t\trepo: repo,\n\t\t\tpull_number: pr,\n\t\t\treviewers: userReviews,\n\t\t\tteam_reviewers: teamReviews,\n\t\t} );\n\t\tcore.info( `Requested review(s) from ${ teams }` );\n\t} catch ( err ) {\n\t\tthrow new Error( `Unable to request review.\\n  Error: ${ err }` );\n\t}\n}\n\nmodule.exports = requestReviewer;\n","const assert = require( 'assert' );\nconst core = require( '@actions/core' );\nconst github = require( '@actions/github' );\nconst { SError } = require( 'error' );\nconst picomatch = require( 'picomatch' );\nconst fetchTeamMembers = require( './team-members.js' );\n\nclass RequirementError extends SError {}\n\n/**\n * Prints a result set, then returns it.\n *\n * @param {string}   label         - Label for the set.\n * @param {string[]} teamReviewers - Team members that have reviewed the file. If an empty array, will print `<empty set>` instead.\n * @param {string[]} neededTeams   - Teams that have no reviews from it's members.\n * @return {{teamReviewers, neededTeams}} `{teamReviewers, neededTeams}`.\n */\nfunction printSet( label, teamReviewers, neededTeams ) {\n\tcore.info( label + ' ' + ( teamReviewers.length ? teamReviewers.join( ', ' ) : '<empty set>' ) );\n\treturn { teamReviewers, neededTeams };\n}\n\n/**\n * Build a reviewer team membership filter.\n *\n * @param {object}              config     - Requirements configuration object being processed.\n * @param {Array|string|object} teamConfig - Team name, or single-key object with a list of teams/objects, or array of such.\n * @param {string}              indent     - String for indentation.\n * @return {Function} Function to filter an array of reviewers by membership in the team(s).\n */\nfunction buildReviewerFilter( config, teamConfig, indent ) {\n\tif ( typeof teamConfig === 'string' ) {\n\t\tconst team = teamConfig;\n\t\treturn async function ( reviewers ) {\n\t\t\tconst members = await fetchTeamMembers( team );\n\t\t\tconst teamReviewers = reviewers.filter( reviewer => members.includes( reviewer ) );\n\t\t\tconst neededTeams = teamReviewers.length ? [] : [ team ];\n\t\t\treturn printSet( `${ indent }Members of ${ team }:`, teamReviewers, neededTeams );\n\t\t};\n\t}\n\n\tlet keys;\n\ttry {\n\t\tkeys = Object.keys( teamConfig );\n\t\tassert( keys.length === 1 );\n\t} catch {\n\t\tthrow new RequirementError( 'Expected a team name or a single-keyed object.', {\n\t\t\tconfig: config,\n\t\t\tvalue: teamConfig,\n\t\t} );\n\t}\n\n\tconst op = keys[ 0 ];\n\tlet arg = teamConfig[ op ];\n\n\t// Shared validation.\n\tswitch ( op ) {\n\t\tcase 'any-of':\n\t\tcase 'all-of':\n\t\tcase 'is-author-or-reviewer':\n\t\t\t// These ops require an array of teams/objects.\n\t\t\tif ( ! Array.isArray( arg ) ) {\n\t\t\t\tthrow new RequirementError( `Expected an array of teams, got ${ typeof arg }`, {\n\t\t\t\t\tconfig: config,\n\t\t\t\t\tvalue: arg,\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( arg.length === 0 ) {\n\t\t\t\tthrow new RequirementError( 'Expected a non-empty array of teams', {\n\t\t\t\t\tconfig: config,\n\t\t\t\t\tvalue: teamConfig,\n\t\t\t\t} );\n\t\t\t}\n\t\t\targ = arg.map( t => buildReviewerFilter( config, t, `${ indent }  ` ) );\n\t\t\tbreak;\n\t}\n\n\t// Process operations.\n\tif ( op === 'any-of' ) {\n\t\treturn async function ( reviewers ) {\n\t\t\tcore.info( `${ indent }Union of these:` );\n\t\t\tconst reviewersAny = await Promise.all( arg.map( f => f( reviewers, `${ indent }  ` ) ) );\n\t\t\tconst requirementsMet = [];\n\t\t\tconst neededTeams = [];\n\t\t\tfor ( const requirementResult of reviewersAny ) {\n\t\t\t\tif ( requirementResult.teamReviewers.length !== 0 ) {\n\t\t\t\t\trequirementsMet.push( requirementResult.teamReviewers );\n\t\t\t\t}\n\t\t\t\tif ( requirementResult.neededTeams.length !== 0 ) {\n\t\t\t\t\tneededTeams.push( requirementResult.neededTeams );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( requirementsMet.length > 0 ) {\n\t\t\t\t// If there are requirements met, zero out the needed teams\n\t\t\t\tneededTeams.length = 0;\n\t\t\t}\n\t\t\treturn printSet(\n\t\t\t\t`${ indent }=>`,\n\t\t\t\t[ ...new Set( requirementsMet.flat( 1 ) ) ],\n\t\t\t\t[ ...new Set( neededTeams.flat( 1 ) ) ]\n\t\t\t);\n\t\t};\n\t}\n\n\tif ( op === 'all-of' ) {\n\t\treturn async function ( reviewers ) {\n\t\t\tcore.info( `${ indent }Union of these, if none are empty:` );\n\t\t\tconst reviewersAll = await Promise.all( arg.map( f => f( reviewers, `${ indent }  ` ) ) );\n\t\t\tconst requirementsMet = [];\n\t\t\tconst neededTeams = [];\n\t\t\tfor ( const requirementResult of reviewersAll ) {\n\t\t\t\tif ( requirementResult.teamReviewers.length !== 0 ) {\n\t\t\t\t\trequirementsMet.push( requirementResult.teamReviewers );\n\t\t\t\t}\n\t\t\t\tif ( requirementResult.neededTeams.length !== 0 ) {\n\t\t\t\t\tneededTeams.push( requirementResult.neededTeams );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( neededTeams.length !== 0 ) {\n\t\t\t\t// If there are needed teams, zero out requirements met\n\t\t\t\treturn printSet( `${ indent }=>`, [], [ ...new Set( neededTeams.flat( 1 ) ) ] );\n\t\t\t}\n\t\t\treturn printSet( `${ indent }=>`, [ ...new Set( requirementsMet.flat( 1 ) ) ], [] );\n\t\t};\n\t}\n\n\tif ( op === 'is-author-or-reviewer' ) {\n\t\treturn async function ( reviewers ) {\n\t\t\tcore.info( `${ indent }Author or reviewers are union of these:` );\n\t\t\tconst authorOrReviewers = [ ...reviewers, github.context.payload.pull_request.user.login ];\n\t\t\tconst reviewersAny = await Promise.all(\n\t\t\t\targ.map( f => f( authorOrReviewers, `${ indent }  ` ) )\n\t\t\t);\n\t\t\tconst requirementsMet = [];\n\t\t\tconst neededTeams = [];\n\t\t\tfor ( const requirementResult of reviewersAny ) {\n\t\t\t\tif ( requirementResult.teamReviewers.length !== 0 ) {\n\t\t\t\t\trequirementsMet.push( requirementResult.teamReviewers );\n\t\t\t\t}\n\t\t\t\tif ( requirementResult.neededTeams.length !== 0 ) {\n\t\t\t\t\tneededTeams.push( requirementResult.neededTeams );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( requirementsMet.length > 0 ) {\n\t\t\t\t// If there are requirements met, zero out the needed teams\n\t\t\t\tneededTeams.length = 0;\n\t\t\t}\n\t\t\treturn printSet(\n\t\t\t\t`${ indent }=>`,\n\t\t\t\t[ ...new Set( requirementsMet.flat( 1 ) ) ],\n\t\t\t\t[ ...new Set( neededTeams.flat( 1 ) ) ]\n\t\t\t);\n\t\t};\n\t}\n\n\tthrow new RequirementError( `Unrecognized operation \"${ op }\"`, {\n\t\tconfig: config,\n\t\tvalue: teamConfig,\n\t} );\n}\n\n/**\n * Class representing an individual requirement.\n */\nclass Requirement {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {object}          config         - Object config\n\t * @param {string[]|string} config.paths   - Paths this requirement applies to. Either an array of picomatch globs, or the string \"unmatched\".\n\t * @param {Array}           config.teams   - Team reviews requirements.\n\t * @param {boolean}         config.consume - Whether matched paths should be ignored by later rules.\n\t */\n\tconstructor( config ) {\n\t\tthis.name = config.name || 'Unnamed requirement';\n\n\t\tif ( config.paths === 'unmatched' ) {\n\t\t\tthis.pathsFilter = null;\n\t\t} else if (\n\t\t\tArray.isArray( config.paths ) &&\n\t\t\tconfig.paths.length > 0 &&\n\t\t\tconfig.paths.every( v => typeof v === 'string' )\n\t\t) {\n\t\t\t// picomatch doesn't combine multiple negated patterns in a way that makes sense here: `!a` and `!b` will pass both `a` and `b`\n\t\t\t// because `a` matches `!b` and `b` matches `!a`. So instead we have to handle the negation ourself: test the (non-negated) patterns in order,\n\t\t\t// with the last match winning. If none match, the opposite of the first pattern's negation is what we need.\n\t\t\tconst filters = config.paths.map( path => {\n\t\t\t\tif ( path.startsWith( '!' ) ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnegated: true,\n\t\t\t\t\t\tfilter: picomatch( path.substring( 1 ), { dot: true, nonegate: true } ),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tnegated: false,\n\t\t\t\t\tfilter: picomatch( path, { dot: true } ),\n\t\t\t\t};\n\t\t\t} );\n\t\t\tconst first = filters.shift();\n\t\t\tthis.pathsFilter = v => {\n\t\t\t\tlet ret = first.filter( v ) ? ! first.negated : first.negated;\n\t\t\t\tfor ( const filter of filters ) {\n\t\t\t\t\tif ( filter.filter( v ) ) {\n\t\t\t\t\t\tret = ! filter.negated;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new RequirementError(\n\t\t\t\t'Paths must be a non-empty array of strings, or the string \"unmatched\".',\n\t\t\t\t{\n\t\t\t\t\tconfig: config,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tthis.reviewerFilter = buildReviewerFilter( config, { 'any-of': config.teams }, '  ' );\n\t\tthis.consume = !! config.consume;\n\t}\n\n\t// eslint-disable-next-line jsdoc/require-returns, jsdoc/require-returns-check -- Doesn't support documentation of object structure.\n\t/**\n\t * Test whether this requirement applies to the passed paths.\n\t *\n\t * @param {string[]} paths        - Paths to test against.\n\t * @param {string[]} matchedPaths - Paths that have already been matched.\n\t * @return {object} _ Results object.\n\t * @return {boolean} _.applies Whether the requirement applies.\n\t * @return {string[]} _.matchedPaths New value for `matchedPaths`.\n\t * @return {string[]} _.paths New value for `paths`.\n\t */\n\tappliesToPaths( paths, matchedPaths ) {\n\t\tlet matches;\n\t\tif ( this.pathsFilter ) {\n\t\t\tmatches = paths.filter( p => this.pathsFilter( p ) );\n\t\t} else {\n\t\t\tmatches = paths.filter( p => ! matchedPaths.includes( p ) );\n\t\t\tif ( matches.length === 0 ) {\n\t\t\t\tcore.info( \"Matches files that haven't been matched yet, but all files have.\" );\n\t\t\t}\n\t\t}\n\n\t\tconst ret = {\n\t\t\tapplies: matches.length !== 0,\n\t\t\tmatchedPaths,\n\t\t\tpaths,\n\t\t};\n\n\t\tif ( ret.applies ) {\n\t\t\tcore.info( 'Matches the following files:' );\n\t\t\tmatches.forEach( m => core.info( `   - ${ m }` ) );\n\t\t\tret.matchedPaths = [ ...new Set( [ ...matchedPaths, ...matches ] ) ].sort();\n\n\t\t\tif ( this.consume ) {\n\t\t\t\tcore.info( 'Consuming matched files!' );\n\t\t\t\tret.paths = ret.paths.filter( p => ! matches.includes( p ) );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Test whether this requirement is satisfied.\n\t *\n\t * @param {string[]} reviewers - Reviewers to test against.\n\t * @return {string[]} Array of teams from which review is still needed.\n\t */\n\tasync needsReviewsFrom( reviewers ) {\n\t\tcore.info( 'Checking reviewers...' );\n\t\tconst checkNeededTeams = await this.reviewerFilter( reviewers );\n\t\treturn checkNeededTeams.neededTeams;\n\t}\n}\n\nmodule.exports = Requirement;\n","const core = require( '@actions/core' );\nconst github = require( '@actions/github' );\nconst { WError } = require( 'error' );\n\n/**\n * Fetch the reviewers approving the current PR.\n *\n * @return {string[]} Reviewers.\n */\nasync function fetchReviewers() {\n\tconst octokit = github.getOctokit( core.getInput( 'token', { required: true } ) );\n\tconst owner = github.context.payload.repository.owner.login;\n\tconst repo = github.context.payload.repository.name;\n\tconst pr = github.context.payload.pull_request.number;\n\n\tconst reviewers = new Set();\n\ttry {\n\t\tfor await ( const res of octokit.paginate.iterator( octokit.rest.pulls.listReviews, {\n\t\t\towner: owner,\n\t\t\trepo: repo,\n\t\t\tpull_number: pr,\n\t\t\tper_page: 100,\n\t\t} ) ) {\n\t\t\tres.data.forEach( review => {\n\t\t\t\t// GitHub may return more than one review per user, but only counts the last non-comment one for each.\n\t\t\t\t// \"APPROVED\" allows merging, while \"CHANGES_REQUESTED\" and \"DISMISSED\" do not.\n\t\t\t\tif ( review.state === 'APPROVED' ) {\n\t\t\t\t\treviewers.add( review.user.login );\n\t\t\t\t} else if ( review.state !== 'COMMENTED' ) {\n\t\t\t\t\treviewers.delete( review.user.login );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} catch ( error ) {\n\t\tthrow new WError(\n\t\t\t`Failed to query ${ owner }/${ repo } PR #${ pr } reviewers from GitHub`,\n\t\t\terror,\n\t\t\t{}\n\t\t);\n\t}\n\n\treturn [ ...reviewers ].sort();\n}\n\nmodule.exports = fetchReviewers;\n","const core = require( '@actions/core' );\nconst github = require( '@actions/github' );\nconst { WError } = require( 'error' );\nconst addVirtualTeams = require( './virtual-teams.js' );\n\nconst cache = {};\n\n/**\n * Fetch the members of a team for the purpose of verifying a review Requirement.\n * Special case: Names prefixed with @ are considered to be a one-member team with the named GitHub user.\n *\n * @param {string} team - GitHub team slug, or @ followed by a GitHub user name.\n * @return {string[]} Team members.\n */\nasync function fetchTeamMembers( team ) {\n\tif ( cache[ team ] ) {\n\t\treturn cache[ team ];\n    }\n\tconst octokit = github.getOctokit( core.getInput( 'token', { required: true } ) );\n\tconst org = github.context.payload.repository.owner.login;\n\n\tlet members = [];\n\tif ( team.startsWith( '@' ) ) {\n\t\t// Handle @singleuser virtual teams. Fetch the correct username case from GitHub\n\t\t// to avoid having to worry about edge cases and Unicode versions and such.\n\t\ttry {\n\t\t\tconst res = await octokit.rest.users.getByUsername( { username: team.slice( 1 ) } );\n\t\t\tmembers.push( res.data.login );\n\t\t} catch ( error ) {\n\t\t\tthrow new WError(\n\t\t\t\t// prettier-ignore\n\t\t\t\t`Failed to query user ${ team } from GitHub: ${ error.response?.data?.message || error.message }`,\n\t\t\t\terror,\n\t\t\t\t{}\n\t\t\t);\n\t\t}\n\t} else if ( team.startsWith( '+' ) ) {\n        // Handle #virtual teams. Fetch the correct usernames case from GitHub\n        // to avoid having to worry about edge cases and Unicode versions and such.\n        await addVirtualTeams( members, team );\n\t} else {\n\t\ttry {\n\t\t\tfor await ( const res of octokit.paginate.iterator( octokit.rest.teams.listMembersInOrg, {\n\t\t\t\torg: org,\n\t\t\t\tteam_slug: team,\n\t\t\t\tper_page: 100,\n\t\t\t} ) ) {\n\t\t\t\tmembers = members.concat( res.data.map( v => v.login ) );\n\t\t\t}\n\t\t} catch ( error ) {\n\t\t\tthrow new WError(\n\t\t\t\t// prettier-ignore\n\t\t\t\t`Failed to query ${ org } team ${ team } from GitHub: ${ error.response?.data?.message || error.message }`,\n\t\t\t\terror,\n\t\t\t\t{}\n\t\t\t);\n\t\t}\n\t}\n\n\tcache[ team ] = members;\n\treturn members;\n}\n\nmodule.exports = fetchTeamMembers;\n","\nconst core = require( '@actions/core' );\nconst github = require( '@actions/github' );\n\nconst virtualTeams = {};\n\nasync function addVirtualTeams(members, team) {\n    if ( ! virtualTeams ) {\n        const teamsFilename = core.getInput( 'virtual-teams-file' );\n        let virtualTeamsString = \"\";\n        if ( ! teamsFilename ) {\n            throw new reporter.ReportError(\n                'Virtual teams are not found',\n                new Error( 'To use +virtual-teams a virtual-teams-file must be provided' ),\n                {}\n            );\n        }\n        try {\n            virtualTeamsString = fs.readFileSync( teamsFilename, 'utf8' );\n        } catch ( error ) {\n            throw new reporter.ReportError(\n                `Virtual teams file ${ filename } could not be read`,\n                error,\n                {}\n            );\n        }\n        try {\n            virtualTeamsArray = yaml.load( virtualTeamsString, {\n                onWarning: w => core.warning( `Yaml: ${ w.message }` ),\n            } );\n            if ( ! Array.isArray( virtualTeams ) ) {\n                throw new Error( 'Virtual teams file does not contain an array' );\n            }\n        } catch ( error ) {\n            error[ Symbol.toStringTag ] = 'Error'; // Work around weird check in WError.\n            throw new reporter.ReportError( 'Virtual teams are not valid', error, {} );\n        }\n        for ( const vt of virtualTeamsArray ) {\n            if ( vt.name.startsWith( '+' ) ) {\n                virtualTeams[ vt.name ] = vt.members;\n            } else {\n                throw new reporter.ReportError(\n                    `Virtual team ${ vt.name } does not start with +`,\n                    new Error( 'Virtual teams must start with +' ),\n                    {}\n                );\n            }\n        }\n    }\n    for ( const member of virtualTeams[team] ) {\n        try {\n            const res = await octokit.rest.users.getByUsername( { username: member } );\n            members.push( res.data.login );\n        } catch ( error ) {\n            throw new WError(\n                // prettier-ignore\n                `Failed to query user ${ member } from GitHub: ${ error.response?.data?.message || error.message }`,\n                error,\n                {}\n            );\n        }\n    }\n}\n\nmodule.exports = addVirtualTeams;\n",null,"module.exports = require(\"assert\");","module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const fs = require( 'fs' );\nconst core = require( '@actions/core' );\nconst yaml = require( 'js-yaml' );\nconst reporter = require( './reporter.js' );\nconst requestReview = require( './request-review.js' );\nconst Requirement = require( './requirement.js' );\n\n/**\n * Load the requirements yaml file.\n *\n * @return {Requirement[]} Requirements.\n */\nasync function getRequirements() {\n\tlet requirementsString = core.getInput( 'requirements' );\n\n\tif ( ! requirementsString ) {\n\t\tconst filename = core.getInput( 'requirements-file' );\n\t\tif ( ! filename ) {\n\t\t\tthrow new reporter.ReportError(\n\t\t\t\t'Requirements are not found',\n\t\t\t\tnew Error( 'Either `requirements` or `requirements-file` input is required' ),\n\t\t\t\t{}\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\trequirementsString = fs.readFileSync( filename, 'utf8' );\n\t\t} catch ( error ) {\n\t\t\tthrow new reporter.ReportError(\n\t\t\t\t`Requirements file ${ filename } could not be read`,\n\t\t\t\terror,\n\t\t\t\t{}\n\t\t\t);\n\t\t}\n\t} else if ( core.getInput( 'requirements-file' ) ) {\n\t\tcore.warning( 'Ignoring input `requirements-file` because `requirements` was given' );\n\t}\n\n\ttry {\n\t\tconst requirements = yaml.load( requirementsString, {\n\t\t\tonWarning: w => core.warning( `Yaml: ${ w.message }` ),\n\t\t} );\n\t\tif ( ! Array.isArray( requirements ) ) {\n\t\t\tthrow new Error( 'Requirements file does not contain an array' );\n\t\t}\n\n\t\treturn requirements.map( ( r, i ) => new Requirement( { name: `#${ i }`, ...r } ) );\n\t} catch ( error ) {\n\t\terror[ Symbol.toStringTag ] = 'Error'; // Work around weird check in WError.\n\t\tthrow new reporter.ReportError( 'Requirements are not valid', error, {} );\n\t}\n}\n\n/**\n * Action entry point.\n */\nasync function main() {\n\ttry {\n\t\tconst requirements = await getRequirements();\n\t\tcore.startGroup( `Loaded ${ requirements.length } review requirement(s)` );\n\n\t\tconst reviewers = await require( './reviewers.js' )();\n\t\tcore.startGroup( `Found ${ reviewers.length } reviewer(s)` );\n\t\treviewers.forEach( r => core.info( r ) );\n\t\tcore.endGroup();\n\n\t\tlet paths = await require( './paths.js' )();\n\t\tcore.startGroup( `PR affects ${ paths.length } file(s)` );\n\t\tpaths.forEach( p => core.info( p ) );\n\t\tcore.endGroup();\n\n\t\tlet matchedPaths = [];\n\t\tconst teamsNeededForReview = new Set();\n\t\tfor ( let i = 0; i < requirements.length; i++ ) {\n\t\t\tconst r = requirements[ i ];\n\t\t\tcore.startGroup( `Checking requirement \"${ r.name }\"...` );\n\t\t\tlet applies;\n\t\t\t( { applies, matchedPaths, paths } = r.appliesToPaths( paths, matchedPaths ) );\n\t\t\tif ( ! applies ) {\n\t\t\t\tcore.endGroup();\n\t\t\t\tcore.info( `Requirement \"${ r.name }\" does not apply to any files in this PR.` );\n\t\t\t} else {\n\t\t\t\tconst neededForRequirement = await r.needsReviewsFrom( reviewers );\n\t\t\t\tcore.endGroup();\n\t\t\t\tif ( neededForRequirement.length === 0 ) {\n\t\t\t\t\tcore.info( `Requirement \"${ r.name }\" is satisfied by the existing reviews.` );\n\t\t\t\t} else {\n\t\t\t\t\tcore.error( `Requirement \"${ r.name }\" is not satisfied by the existing reviews.` );\n\t\t\t\t\tneededForRequirement.forEach( teamsNeededForReview.add, teamsNeededForReview );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( teamsNeededForReview.size === 0 ) {\n\t\t\tawait reporter.status( reporter.STATE_SUCCESS, 'All required reviews have been provided!' );\n\t\t} else {\n\t\t\tawait reporter.status(\n\t\t\t\tcore.getBooleanInput( 'fail' ) ? reporter.STATE_FAILURE : reporter.STATE_PENDING,\n\t\t\t\treviewers.length ? 'Awaiting more reviews...' : 'Awaiting reviews...'\n\t\t\t);\n\t\t\tif ( core.getBooleanInput( 'request-reviews' ) ) {\n\t\t\t\tawait requestReview( [ ...teamsNeededForReview ] );\n\t\t\t}\n\t\t}\n\t} catch ( error ) {\n\t\tlet err, state, description;\n\t\tif ( error instanceof reporter.ReportError ) {\n\t\t\terr = error.cause();\n\t\t\tstate = reporter.STATE_FAILURE;\n\t\t\tdescription = error.message;\n\t\t} else {\n\t\t\terr = error;\n\t\t\tstate = reporter.STATE_ERROR;\n\t\t\tdescription = 'Action encountered an error';\n\t\t}\n\t\tcore.setFailed( err.message );\n\t\tcore.info( err.stack );\n\t\tif ( core.getInput( 'token' ) && core.getInput( 'status' ) ) {\n\t\t\tawait reporter.status( state, description );\n\t\t}\n\t}\n}\n\nmain();\n"],"names":[],"sourceRoot":""}